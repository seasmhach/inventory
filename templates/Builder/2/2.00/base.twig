<?php
{% include 'license.twig' %}

namespace Builder;
use ArrayIterator;
use Seasmhach\Nehemiah\DataObject;
{% if table.use|length > 0 %}
use Builder\{{ '{' }}{% for namespace in table.use %}{{ namespace }}{% if false == loop.last %}, {% endif %}{% endfor %}{{ '}' }};
{% endif %}
use PDO;

/**
 * Build with builder:
 *
 * Build date: {{ 'now'|date('Y-m-d H:i:s') }}
 * Template version: {{ version }}
 *
 * Please DO NOT edit this file manually. The file will be overwritten when the
 * builder is called again!
 */
class Base{{ namespace }} extends ArrayIterator {
	const ASSIGN = 1;
	const INCREMENT = 2;
	const DECREMENT = 3;

	protected $alias = '';

	/** @var array Alias/Column pairs to be used in SELECT statements */
	protected $list = [];

	/** @var array Column/Value pairs to be set in a UPDATE or CREATE statement */
	protected $columns = [];

	/** @var array Placeholder/Value pairs */
	protected $parameters = [];

	/** @var array Conditions on which the WHERE clause will be build */
	protected $where = [];

	/** @var array Joined objects */
	protected $joins = [];

	/** @var array Columns by which to group */
	protected $group = [];

	/** @var string|null MySQL Limit clause */
	protected $limit = null;

	/** @var array Order by columns */
	protected $order = [];

	public static function read_by_{% for column in table.primary_key %}{{ column }}{% if false == loop.last %}_and_{% endif %}{% endfor %}({% for column in table.primary_key %}{{ table.columns[column].data_type }} ${{ column }}, {% endfor %}array $columns = []) {
		${{ table_name }} = new self;
{% for column in table.primary_key %}
		${{ table_name }}->{{ column }}_is(${{ column }});
{% endfor %}

		foreach ($columns as $column) {
			${{ table_name }}->list($column, $column);
		}

		if (${{ table_name }}->select()) {
			return ${{ table_name }}->current();
		}

		return null;
	}

	public static function update_by_{% for column in table.primary_key %}{{ column }}{% if false == loop.last %}_and_{% endif %}{% endfor %}({% for column in table.primary_key %}{{ table.columns[column].data_type }} ${{ column }}, {% endfor %}array $columns = null) {
		${{ table_name }} = new self;
{% for column in table.primary_key %}
		${{ table_name }}->{{ column }}_is(${{ column }});
{% endfor %}
		${{ table_name }}->set($columns);

		return ${{ table_name }}->update();
	}

	public static function check_existence_by_{% for column in table.primary_key %}{{ column }}{% if false == loop.last %}_and_{% endif %}{% endfor %}({% for column in table.primary_key %}{{ table.columns[column].data_type }} ${{ column }}{% if false == loop.last %}, {% endif %}{% endfor %}) {
		${{ table_name }} = new self;
		${{ table_name }}->list('1', 'exists');
{% for column in table.primary_key %}
		${{ table_name }}->{{ column }}_is(${{ column }});
{% endfor %}

		if (${{ table_name }}->select()) {
			return true;
		}

		return false;
	}

{% for reference in table.native_foreign_keys %}
	public static function read_by_{% for column in reference %}{{ column }}{% if false == loop.last %}_and_{% endif %}{% endfor %}({% for column in reference %}{{ table.columns[column].data_type }} ${{ column }}, {% endfor %}array $columns = []) {
		${{ table_name }} = new self;
{% for column in reference %}
		${{ table_name }}->{{ column }}_is(${{ column }});
{% endfor %}

		foreach ($columns as $column) {
			${{ table_name }}->list($column, $column);
		}

		${{ table_name }}->select();

		return ${{ table_name }};
	}
{% endfor %}

{% for key in table.unique_keys %}
	public static function check_existence_by_{% for column in key %}{{ column }}{% if false == loop.last %}_and_{% endif %}{% endfor %}({% for column in key %}{{ table.columns[column].data_type }} ${{ column }}{% if false == loop.last %}, {% endif %}{% endfor %}) {
		${{ table_name }}_instance = new self;
		${{ table_name }}_instance->list('1', 'exists');
{% for column in key %}
		${{ table_name }}_instance->{{ column }}_is(${{ column }});
{% endfor %}

		if (${{ table_name }}_instance->select()) {
			return true;
		}

		return false;
	}

	/**
	 *
{% for column in key %}
	 * Find a {{ table_name }} by a unique key
	 *
	 * @param {{ table.columns[column].data_type }} ${{ column }} {{ table.columns[column].comment }}
{% endfor %}
	 * @return mixed Returns an array of values as specified in the column parameters or NULL of no result was found
	 */
	public static function read_by_{% for column in key %}{{ column }}{% if false == loop.last %}_and_{% endif %}{% endfor %}({% for column in key %}{{ table.columns[column].data_type }} ${{ column }}, {% endfor %}array $columns = []) {
		${{ table_name }}_instance = new self;
{% for column in key %}
		${{ table_name }}_instance->{{ column }}_is(${{ column }});
{% endfor %}

		foreach ($columns as $column) {
			${{ table_name }}_instance->list($column, $column);
		}

		if (${{ table_name }}_instance->select()) {
			return ${{ table_name }}_instance->current();
		}

		return null;
	}

{% endfor %}
	public static function read_all(array $columns = []) {
		${{ table_name }} = new self;

		foreach ($columns as $column) {
			${{ table_name }}->list($column, $column);
		}

		${{ table_name }}->select();

		return ${{ table_name }};
	}

	public function __construct(string $alias = '{{ table_name }}', bool $include = true) {
		$this->alias = $alias;

		parent::__construct();
	}

{% include 'list.twig' %}
{% include 'set.twig' %}
{% include 'where.twig' %}
{% include 'join.twig' %}
{% include 'group.twig' %}
{% include 'order.twig' %}

	public function get_list() {
		return $this->list;
	}

	public function collect() {
		$list = $this->list;
		$columns = $this->columns;
		$where = $this->where;
		$parameters = $this->parameters;
		$joins = [];
		$group = $this->group;
		$order = $this->order;
		$tables = [];

		foreach ($this->joins as $join) {
			if (is_array($join)) {
				$joins[] = $join['sql'];

				if (true === $join['include']) {
					$tables[] = $join['table'];
				}
			} else {
				$joins[] = $join;
			}
		}

		foreach ($this->joins as $join) {
			if (is_array($join)) {
				$information = $join['builder']->collect();

				$list = array_merge($list, $information['list']);
				$columns = array_merge($columns, $information['columns']);
				$where = array_merge($where, $information['where']);
				$parameters = array_merge($parameters, $information['parameters']);
				$joins = array_merge($joins, $information['joins']);
				$group = array_merge($group, $information['group']);
				$order = array_merge($order, $information['order']);
				$tables = array_merge($tables, $information['tables']);
			}
		}

		return [
			'list' => $list,
			'columns' => $columns,
			'where' => $where,
			'parameters' => $parameters,
 			'joins' => $joins,
			'group' => $group,
			'order' => $order,
			'tables' => $tables,
		];
	}

	public function update(int &$affacted_rows = 0) {
		$information = $this->collect();
		$pdo = DataObject::pdo_instance('{{ database }}');
		$set = [];

		foreach ($information['columns'] as $column_name => $column) {
			$sql = $column['alias'] . '.' . $column_name . ' = ';

			if ($column['operator'] !== self::ASSIGN) {
				$sql .= $column['alias'] . '.' . $column_name . ' ';
				$sql .= ($column['operator'] === self::INCREMENT) ? ' + ' : ' - ';
			}

			$sql .= ':' . $column_name;

			$set[] = $sql;
		}

		$sql = "UPDATE `{{ table_name }}` AS `$this->alias`";

		if (count($information['joins'])) {
			$sql .= "\n" . implode("\n", $information['joins']);
		}

		$sql .= "\nSET";
		$sql .= "\n\t" . implode(",\n\t", $set);

		if (count($information['where'])) {
			$sql .= "\nWHERE\n\t" . implode("\nAND\n\t", $information['where']);
		}

		if ($this->limit) {
			$sql .= "\n$this->limit";
		}

		$statement = $pdo->prepare($sql);

		foreach ($information['columns'] as $column_name => $column) {
			$statement->bindValue(':' . $column_name, $column['value'], (is_null($column['value']) || is_int($column['value'])) ? PDO::PARAM_INT : PDO::PARAM_STR);
		}

		foreach ($information['parameters'] as $placeholder => $value) {
			$statement->bindValue(':' . $placeholder, $value, (is_null($value) || is_int($value)) ? PDO::PARAM_INT : PDO::PARAM_STR);
		}

		if (true === $statement->execute()) {
			$affected_rows = $statement->rowCount();

			return true;
		}

		return false;
	}

	public function insert() {
		$information = $this->collect();
		$pdo = DataObject::pdo_instance('{{ database }}');

		$sql = "INSERT INTO `{{ table_name }}`";
		$sql .= "\n\t(`" . implode('`, `', array_keys($information['columns'])) . "`)";
		$sql .= "\nVALUES";
		$sql .= "\n\t(:" . implode(", :", array_keys($information['columns'])) . ")";

		$statement = $pdo->prepare($sql);

		foreach ($information['columns'] as $column_name => $column) {
			$statement->bindValue(':' . $column_name, $column['value'], (is_null($column['value']) || is_int($column['value'])) ? PDO::PARAM_INT : PDO::PARAM_STR);
		}

		if (true === $statement->execute()) {
			$this->columns = [];

{% if table.primary_key|length == 1 and true == table.columns[table.primary_key[0]].auto_increment %}
			${{ table.primary_key[0] }} = (int) $pdo->lastInsertId();
			$information['columns']['{{ table.primary_key[0] }}'] = ${{ table.primary_key[0] }};

			$this->append($information['columns']);

			return ${{ table.primary_key[0] }};
{% else %}
			return true;
{% endif %}
		}

		return false;
	}

	public function select(bool $debug = false) {
		$information = $this->collect();
		$pdo = DataObject::pdo_instance('{{ database }}');

		$sql = "SELECT\n\t";
		$sql .= (count($information['list'])) ? implode(",\n\t", $information['list']) : '*';
		$sql .= "\nFROM `{{ table_name }}` AS `$this->alias`";

		if (count($information['joins'])) {
			$sql .= "\n" . implode("\n", $information['joins']);
		}

		if (count($information['where'])) {
			$sql .= "\nWHERE\n\t" . implode("\nAND\n\t", $information['where']);
		}

		if (count($information['group'])) {
			$sql .= "\nGROUP BY\n\t";
			$sql .= implode(",\n\t", $information['group']);
		}

		if (count($information['order'])) {
			$sql .= "\nORDER BY\n\t";
			$sql .= implode(",\n\t", $information['order']);
		}

		if ($this->limit) {
			$sql .= "\n$this->limit";
		}

		if (true === $debug) {
			die($sql);
		}

		$statement = $pdo->prepare($sql);

		if (true === $statement->execute($information['parameters'])) {
			while ($result = $statement->fetch(PDO::FETCH_ASSOC)) {
				$this->append($result);
			}

			return (int) $statement->rowCount();
		}

		return false;
	}

	public function delete(bool $debug = false) {
		$information = $this->collect();
		$pdo = DataObject::pdo_instance('{{ database }}');

		$sql = "DELETE";
		$sql .= "\n\t`$this->alias`";

		if (count($information['tables'])) {
			$sql .= ",\n\t`" . implode("`,\n\t`", $information['tables']) . "`";
		}

		$sql .= "\nFROM `{{ table_name }}` AS `$this->alias`";

		if (count($information['joins'])) {
			$sql .= "\n" . implode("\n", $information['joins']);
		}

		if (count($information['where'])) {
			$sql .= "\nWHERE\n\t" . implode("\nAND\n\t", $information['where']);
		}

		if ($this->limit) {
			$sql .= "\n$this->limit";
		}

		if (true === $debug) {
			print_r($information);
			die($sql);
		}

		$statement = $pdo->prepare($sql);

		if (true === $statement->execute($information['parameters'])) {
			return (int) $statement->rowCount();
		}

		return false;
	}

	public function join() {
		$information = $this->collect();

		$sql = "SELECT\n\t";
		$sql .= (count($information['list'])) ? implode(",\n\t", $information['list']) : '*';
		$sql .= "\nFROM `{{ table_name }}` AS `$this->alias`";

		if (count($information['joins'])) {
			$sql .= "\n" . implode("\n", $information['joins']);
		}

		if (count($information['where'])) {
			$sql .= "\nWHERE\n\t" . implode("\nAND\n\t", $information['where']);
		}

		if (count($information['group'])) {
			$sql .= "\nGROUP BY\n\t";
			$sql .= implode(",\n\t", $information['group']);
		}

		return $sql;
	}

	protected function add_parameter(string $column, $value) {
		$placeholder = count($this->parameters) . '_' . $this->alias . '_' . $column;
		$this->parameters[$placeholder] = $value;

		return ':' . $placeholder;
	}
}
